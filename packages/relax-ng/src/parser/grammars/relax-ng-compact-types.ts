// These types were autogenerated by peggy-to-ts
export type TopLevel = {
    type: "root";
    content: (Decl | GrammarContent | Pattern | Annotation)[];
};
type Decl =
    | {
          type: "declaration";
          declarationType: "namespace";
          name: IdentifierOrKeyword;
          content: NamespaceURILiteral;
      }
    | {
          type: "declaration";
          declarationType: "defaultNamespace";
          name: IdentifierOrKeyword | null;
          content: NamespaceURILiteral;
      }
    | {
          type: "declaration";
          declarationType: "datatypes";
          name: IdentifierOrKeyword;
          content: Literal;
      };
type Pattern =
    | { type: "group"; content: AnnotatedPatternPrimary[] }
    | { type: "interleave"; content: AnnotatedPatternPrimary[] }
    | { type: "choice"; content: AnnotatedPatternPrimary[] }
    | AnnotatedPatternPrimary;
type AnnotatedPatternPrimary =
    | PatternSecondary
    | {
          type: string;
          content: PatternSecondary;
          annotations: Annotations;
          followAnnotations: never[] | NonNullable<FollowAnnotations | null>;
      };
type PatternSecondary =
    | { type: "repeat"; operation: "?" | "*" | "+"; content: PatternPrimary }
    | PatternPrimary;
type PatternPrimary =
    | { type: "element"; name: NameClass; content: Pattern }
    | { type: "attribute"; name: NameClass; content: Pattern }
    | { type: "list"; name: void; content: Pattern }
    | { type: "mixed"; name: void; content: Pattern }
    | { type: "parentRef"; name: Identifier }
    | { type: "empty" }
    | { type: "text" }
    | Datatype
    | Identifier
    | { type: "notAllowed" }
    | ["external", WS, AnyURILiteral, _, Inherit | null]
    | ["grammar", _, "{", _, GrammarContent[], _, "}"];
type Datatype =
    | { type: "datatype"; name: DatatypeName | null; content: DatatypeValue }
    | {
          type: "datatype";
          name: DatatypeName;
          params: never[] | NonNullable<Param[] | null>;
          except: ExceptPattern | null;
      };
type Param =
    | ParamBase
    | { type: string; content: ParamBase; annotations: Annotations };
type ParamBase = [IdentifierOrKeyword, _, "=", _, Literal];
type ExceptPattern = { type: "except"; content: Pattern };
type GrammarContent =
    | GrammarContentBase
    | { type: string; content: GrammarContentBase; annotations: Annotations };
type GrammarContentBase =
    | Start
    | Define
    | { type: "div"; content: GrammarContent[] }
    | {
          type: "include";
          uri: AnyURILiteral;
          inherit: Inherit | null;
          content: never[] | NonNullable<IncludeContent[] | null>;
      }
    | AnnotationElement;
type IncludeContent =
    | IncludeContentBase
    | { type: string; content: IncludeContentBase; annotations: Annotations };
type IncludeContentBase =
    | Define
    | Start
    | { type: "div"; content: IncludeContent[] }
    | AnnotationElement;
type Start = { type: "start"; operation: AssignMethod; content: Pattern };
type Define = {
    type: "define";
    name: Identifier;
    operation: AssignMethod;
    content: Pattern;
};
type AssignMethod = "=" | "|=" | "&=";
type NameClass = { type: "nameclassList"; content: AnnotatedNameClass[] };
type AnnotatedNameClass =
    | NameClassPrimary
    | {
          type: string;
          content: NameClassPrimary;
          annotations: Annotations;
          followAnnotations: never[] | NonNullable<FollowAnnotations | null>;
      };
type NameClassPrimary =
    | NameClassPrimaryBase
    | { type: string; content: NameClassPrimaryBase; annotations: Annotations };
type NameClassPrimaryBase =
    | { type: "nameclass"; name: AnyName; except: ExceptNameClass | null }
    | { type: "nameclass"; name: NsName; except: ExceptNameClass | null }
    | { type: "nameclass"; name: Name }
    | NameClass;
type Name = CName | IdentifierOrKeyword;
type ExceptNameClass = NameClassPrimary;
type DatatypeName = CName | "string" | "token";
type DatatypeValue = Literal;
type AnyURILiteral = Literal;
type NamespaceURILiteral = Literal | "inherit";
type Inherit = ["inherit", _, "=", _, IdentifierOrKeyword];
type IdentifierOrKeyword = Identifier | Keyword;
type Identifier = string;
type CName = string;
type NsName = string;
type AnyName = "*";
type Literal = { type: "literal"; parts: LiteralSegment[] };
type LiteralSegment =
    | { type: "literalSegment"; escape: '"""'; value: string }
    | { type: "literalSegment"; escape: "'''"; value: string }
    | { type: "literalSegment"; escape: '"'; value: string };
type FollowAnnotations = (AnnotationElement extends (infer InnerArr)[]
    ? InnerArr
    : AnnotationElement)[];
type AnnotationAttributes = AnnotationAttribute[];
type AnnotationAttribute = {
    type: "annotationAttribute";
    name: Name;
    value: Literal;
};
type AnnotationElement = {
    type: "annotationElement";
    name: Name;
    content: never[] | NonNullable<AnnotationContent[] | null>;
};
type Annotation = {
    type: "annotation";
    content: never[] | NonNullable<AnnotationContent[] | null>;
};
type AnnotationContent = AnnotationAttribute | AnnotationElement | Literal;
type Annotations = ((Documentation | Annotation)[] extends (infer InnerArr)[]
    ? InnerArr extends (infer InnerArr)[]
        ? InnerArr
        : InnerArr
    : (Documentation | Annotation)[])[];
type Documentation = DocumentationLine[];
type DocumentationLine = { type: "documentationLine"; content: string };
type Keyword =
    | "attribute"
    | "default"
    | "datatypes"
    | "div"
    | "element"
    | "empty"
    | "external"
    | "grammar"
    | "include"
    | "inherit"
    | "list"
    | "mixed"
    | "namespace"
    | "notAllowed"
    | "parent"
    | "start"
    | "string"
    | "text"
    | "token";
type Separator = WS | ["#", [string, string[]] | null];
type Newline = string[];
type _ = string[];
type WS = string[];
type NCName = string;
type NCNameStartChar = string | [string, string];
type NCNameChar = NCNameStartChar | string;
type Char = string | [string, string];
